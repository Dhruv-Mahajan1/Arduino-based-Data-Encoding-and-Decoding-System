# LAB PROJECT REPORT G5

*TEAM*: 

- Dhruv (B20EE016)
- Dhruv Shah (B20EE017)
- Divyanshi Singh Bora (B20EE018)

*TITLE*: Hardware implementation of NRZ-L, NRZ-M, NRZ-S, BIO-L, BIO-M, and BIO-S encoding techniques using Arduino board.

*ABSTRACT*: The Arduino board is a versatile and cost-effective platform widely used for rapidly prototyping digital systems. This project demonstrates how the Arduino board can be used to implement different digital encoding techniques commonly used in data communication systems. 

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled.png)

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%201.png)

The NRZ-L, NRZ-M, NRZ-S, BIO-L, BIO-M, and BIO-S encoding techniques are widely used in digital communication systems to encode binary data for transmission over communication channels. These techniques have different advantages and disadvantages, and the choice of the encoding technique depends on the specific application requirements. In this project, we implemented these four encoding techniques using the Arduino board to demonstrate their hardware implementation.

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%202.png)

Data encoding is a crucial aspect of data communication, as it helps improve the accuracy and reliability of data transmission. During data communication, information is transmitted in the form of electrical signals, which can be easily distorted by noise or interference in the communication channel. Encoding techniques are used to convert the original data into a format that is more resistant to noise and interference, making it less likely to be corrupted during transmission.

Encoding techniques not only improve data accuracy and reliability but can also increase data transmission efficiency. Using encoding schemes that reduce the transmitted data or increase transmission speed can improve the overall performance of the communication system.

*EQUIPMENT REQUIRED*: 

- Arduino board
- Arduino USB Type-C Cable 2-in-1
- Arduino IDE
- Connecting wires

*EXPERIMENTAL PROCEDURE*:

- The data pin is set to pin 8 which is configured as an output pin.
- The clock pin is set to pin 3 and in Arduino Uno, the clock signal is generated by an onboard quartz crystal oscillator.
- Then setting the bit period to 100ms is the time for each bit.
- We are assuming the previous last bit value to be false i.e. 0.
- Encoding input data using NRZ-L technique-
    1. **`byte bitValue = bitRead(b, i);`**: This reads the value of the **`i`**th bit of the character **`b`** and assigns it to the variable **`bitValue`**.
    2. **`digitalWrite(dataPin, bitValue ? HIGH : LOW);`**: This sets the output of the **`dataPin`** to either **`HIGH`** or **`LOW`** depending on the value of **`bitValue`**. If **`bitValue`** is true (i.e., 1), then the pin will be set to **`HIGH`**. Otherwise, it will be set to **`LOW`**.
    3. **`Serial.print(bitValue);`**: This sends the value of **`bitValue`** to the serial port for debugging purposes.
    4. **`digitalWrite(clockPin, HIGH);`**: This sets the output of the **`clockPin`** to **`HIGH`**, which sends a clock signal to the receiving device.
    5. **`delay(bitPeriod / 2); // wait half the bit period`**: This causes the program to pause for half of the **`bitPeriod`** before continuing to the next line.
    6. **`digitalWrite(clockPin, LOW);`**: This sets the output of the **`clockPin`** back to **`LOW`**, which ends the clock signal.
    7. **`delay(bitPeriod / 2);`**: This waits for the remaining half of the **`bitPeriod`** before continuing with the next iteration of the loop.

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%203.png)

```arduino
void NRZL(char b) {
  for (int i = 7; i >= 0; i--) {
    byte bitValue = bitRead(b, i);
    digitalWrite(dataPin, bitValue ? HIGH : LOW);
    Serial.print(bitValue);
    digitalWrite(clockPin, HIGH);
    delay(bitPeriod / 2);
    digitalWrite(clockPin, LOW);
    delay(bitPeriod / 2);
   ;
  }
}
```

- Decoding data using NRZ-L technique-
    - For the NRZ-L decoder, we will simply return the current bit.

```arduino
int nrzLdecoder(int byte)
{
  return byte;
}
```

- Encoding input data using NRZ-M technique-
    1. **`digitalWrite(dataPin, signalLevel ? HIGH : LOW);`**: This sets the output of the **`dataPin`** to either **`HIGH`** or **`LOW`** depending on the value of **`signalLevel`**. If **`signalLevel`** is true (i.e., 1), then the pin will be set to **`HIGH`**. Otherwise, it will be set to **`LOW`**.
    2. **`Serial.print(signalLevel);`**: This sends the value of **`signalLevel`** to the serial port for debugging purposes.
    3. **`digitalWrite(clockPin, HIGH);`**: This sets the output of the **`clockPin`** to **`HIGH`**, which sends a clock signal to the receiving device.
    4. **`delay(bitPeriod / 2); // wait half the bit period`**: This causes the program to pause for half of the **`bitPeriod`** before continuing to the next line.
    5. **`digitalWrite(clockPin, LOW);`**: This sets the output of the **`clockPin`** back to **`LOW`**, which ends the clock signal.
    6. **`delay(bitPeriod / 2);`**: This waits for the remaining half of the **`bitPeriod`** before continuing with the next iteration of the loop.
    7. **`lastBitValue = signalLevel;`**: This assigns the value of **`signalLevel`** to **`lastBitValue`**, which is used in the calculation of **`signalLevel`** in the next iteration of the loop.

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%204.png)

```arduino
void NRZM(char b) {
  
  for (int i = 7; i >= 0; i--) {
    byte bitValue = bitRead(b, i);
    bool signalLevel = (bitValue == 1) ? !lastBitValue : lastBitValue;
    digitalWrite(dataPin, signalLevel ? HIGH : LOW);
    Serial.print(signalLevel);
    digitalWrite(clockPin, HIGH);
    delay(bitPeriod / 2);
    digitalWrite(clockPin, LOW);
    delay(bitPeriod / 2);
    lastBitValue = signalLevel;
  }
}
```

- Decoding data using NRZ-M technique-
    - For the NRZ-M decoder, we will XOR the current bit with the previous bit and then store the current bit in the previous bit and return the XOR of the calculated current bit and the previous bit.

```arduino
int nrzmdecoder(int byte)
{
  int nrzm=byte ^ prevbit;
  prevbit=byte;
  return nrzm;
}
```

- Encoding input data using NRZ-S technique-
    - **`bool signalLevel = (bitValue == 0) ? !lastBitValue : lastBitValue;`**: This line determines the signal level based on the current bit value and the last signal level. If the current bit value is 0, then the signal level is the opposite of the last signal level. Otherwise, the signal level is the same as the last signal level.
    - **`digitalWrite(dataPin, signalLevel ? HIGH : LOW);`**: This sets the output of the **`dataPin`** to either **`HIGH`** or **`LOW`** depending on the value of **`signalLevel`**. If **`signalLevel`** is true (i.e., 1), then the pin will be set to **`HIGH`**. Otherwise, it will be set to **`LOW`**.
    - **`Serial.print(signalLevel);`**: This sends the value of **`signalLevel`** to the serial port for debugging purposes.
    - **`digitalWrite(clockPin, HIGH);`**: This sets the output of the **`clockPin`** to **`HIGH`**, which sends a clock signal to the receiving device.
    - **`delay(bitPeriod / 2); // wait half the bit period`**: This causes the program to pause for half of the **`bitPeriod`** before continuing to the next line.
    - **`digitalWrite(clockPin, LOW);`**: This sets the output of the **`clockPin`** back to **`LOW`**, which ends the clock signal.
    - **`delay(bitPeriod / 2);`**: This waits for the remaining half of the **`bitPeriod`** before continuing with the next iteration of the loop.

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%205.png)

```arduino
void NRZS(char b) {
  
  for (int i = 7; i >= 0; i--) {
    byte bitValue = bitRead(b, i);
    bool signalLevel = (bitValue == 0) ? !lastBitValue : lastBitValue;
    digitalWrite(dataPin, signalLevel ? HIGH : LOW);
    Serial.print(signalLevel);
    digitalWrite(clockPin, HIGH);
    delay(bitPeriod / 2);
    digitalWrite(clockPin, LOW);
    delay(bitPeriod / 2);
    lastBitValue = signalLevel;
  }
}
```

- Decoding data using NRZ-S technique-
    - For the NRZ-S decoder, we will XOR the current bit with the previous bit and then store the current bit in the previous bit and return the negation of the XOR of the calculated current bit and the previous bit.

```arduino
int nrzSdecoder(int byte)
{
  int nrzS=byte ^ prevbit;
  prevbit=byte;
  return 1-nrzS;
}
```

- Encoding input data using BIO-L technique-
    1. **`byte bitValue = bitRead(b, i);`** - Reads the **`i`**th bit of the input character **`b`** and stores it in a variable called **`bitValue`**.
    2. **`digitalWrite(dataPin, bitValue ? HIGH : LOW);`** - Sets the output pin connected to the data line to either **`HIGH`** or **`LOW`** based on the value of **`bitValue`**.
    3. **`Serial.print(bitValue);`** - Prints the value of **`bitValue`** to the serial monitor.
    4. **`digitalWrite(clockPin, HIGH);`** - Sets the output pin connected to the clock line to **`HIGH`**.
    5. **`delay(bitPeriod / 2);`** - Waits for half of the bit period before continuing.
    6. **`digitalWrite(dataPin, bitValue ? LOW : HIGH);`** - Sets the output pin connected to the data line to the opposite value of **`bitValue`**.
    7. **`Serial.print(1-bitValue);`** - Prints the opposite value of **`bitValue`** to the serial monitor.
    8. **`digitalWrite(clockPin, LOW);`** - Sets the output pin connected to the clock line to **`LOW`**.
    9. **`delay(bitPeriod / 2);`** - Waits for half of the bit period before continuing.

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%206.png)

```arduino
void BIOL(char b) {
  
  for (int i = 7; i >= 0; i--) {
    byte bitValue = bitRead(b, i);
    digitalWrite(dataPin, bitValue ? HIGH : LOW);
    Serial.print(bitValue);
    digitalWrite(clockPin, HIGH);
    delay(bitPeriod / 2);
    digitalWrite(dataPin, bitValue ? LOW : HIGH);
    Serial.print(1-bitValue);
    digitalWrite(clockPin, LOW);
    delay(bitPeriod / 2);
   ;
  }
}
```

- Decoding data using BIO-L technique-
    - For the BIO-L decoder, we will simply return the current bit.

```arduino
int bioLdecoder(int byte)
{
  return byte;
}
```

- Encoding input data using BIO-M technique-
    1. **`byte bitValue = bitRead(b, i);`**: This reads the **`i`**th bit of the **`char`** argument **`b`** and stores its value in a variable called **`bitValue`**. The **`bitRead()`** function returns either a 0 or a 1.
    2. **`bioout = !bioout;`**: This toggles the value of a global variable called **`bioout`**, which is initially set to 0. This variable is used to control the state of the data pin.
    3. **`digitalWrite(dataPin, bioout ? HIGH : LOW);`**: This sets the state of the data pin based on the value of **`bioout`**. If **`bioout`** is true (i.e. 1), the pin is set to HIGH. Otherwise, it is set to LOW.
    4. **`Serial.print(bioout);`**: This prints the value of **`bioout`** to the serial monitor, which can be useful for debugging.
    5. **`digitalWrite(clockPin, HIGH);`**: This sets the clock pin to HIGH.
    6. **`delay(bitPeriod / 2);`**: This waits for half the bit period. The value of **`bitPeriod`** is assumed to be defined elsewhere in the code.
    7. **`bioout = bitValue ? !bioout : bioout;`**: This updates the value of **`bioout`** based on the value of **`bitValue`**. If **`bitValue`** is true (i.e. 1), **`bioout`** is toggled. Otherwise, it is left unchanged.
    8. **`Serial.print(bioout);`**: This prints the updated value of **`bioout`** to the serial monitor.
    9. **`digitalWrite(dataPin, bioout ? HIGH : LOW);`**: This sets the state of the data pin based on the updated value of **`bioout`**.
    10. **`digitalWrite(clockPin, LOW);`**: This sets the clock pin to LOW.
    11. **`delay(bitPeriod / 2);`**: This waits for half the bit period.

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%207.png)

```arduino
void BIOM(char b) {
  
  for (int i = 7; i >= 0; i--) {
    byte bitValue = bitRead(b, i);
    bioout = !bioout;
    digitalWrite(dataPin, bioout ? HIGH : LOW);
    Serial.print(bioout);
    digitalWrite(clockPin, HIGH);
    delay(bitPeriod / 2); // wait half the bit period
    bioout = bitValue ? !bioout : bioout;
    Serial.print(bioout);
    digitalWrite(dataPin, bioout ? HIGH : LOW);
    digitalWrite(clockPin, LOW);
    delay(bitPeriod / 2);
   ;
  }
}
```

- Decoding data using BIO-M technique-
    - For the BIO-M decoder, we will simply return 0 when even == odd and else 1 is returned.

```arduino
int bioMdecoder(int even, int odd)
{
  return (even==odd) ? 0 : 1;
}
```

- Encoding input data using BIO-S technique-
    - This sends the value of **`bioout`** to the serial monitor, which can be useful for debugging or monitoring the communication.
    - **`digitalWrite(clockPin, HIGH);`**: This sets the value of a digital output pin named **`clockPin`** to **`HIGH`**.
    - **`delay(bitPeriod / 2);`**: This causes the program to pause for a certain amount of time, specified by the variable **`bitPeriod`**, which is divided by 2. This is half of the duration of a single bit.
    - **`bioout = bitValue ? bioout : !bioout;`**: This sets the value of **`bioout`** to either its current value or its inverse, depending on the value of **`bitValue`**. If **`bitValue`** is **`1`**, then **`bioout`** remains the same, otherwise it becomes its inverse.
    - **`Serial.print(bioout);`**: This sends the new value of **`bioout`** to the serial monitor.
    - **`digitalWrite(dataPin, bioout ? HIGH : LOW);`**: This sets the value of **`dataPin`** to either **`HIGH`** or **`LOW`**, depending on the new value of **`bioout`**.
    - **`digitalWrite(clockPin, LOW);`**: This sets the value of **`clockPin`** to **`LOW`**.
    - **`delay(bitPeriod / 2);`**: This causes the program to pause for another half of a bit period before continuing with the next bit.

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%208.png)

```arduino
void BIOS(char b) {
  
  for (int i = 7; i >= 0; i--) {
    byte bitValue = bitRead(b, i);
    bioout = !bioout;
    digitalWrite(dataPin, bioout ? HIGH : LOW);
    Serial.print(bioout);
    digitalWrite(clockPin, HIGH);
    delay(bitPeriod / 2); // wait half the bit period
    bioout = bitValue ? bioout : !bioout;
    Serial.print(bioout);
    digitalWrite(dataPin, bioout ? HIGH : LOW);
    digitalWrite(clockPin, LOW);
    delay(bitPeriod / 2);
   ;
  }
}
```

- Decoding data using BIO-S technique-
    - For the BIO-S decoder, we will simply return 1 when even == odd and else 0 is returned.

```arduino
int bioSdecoder(int even, int odd)
{
  return (even==odd) ? 1 : 0;
}
```

*RESULTS:*

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%209.png)

Fig1: Message & NRZ-L Encoding

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%2010.png)

Fig3: Message & NRZ-S Encoding

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%2011.png)

Fig 5: Message & BIO-M Encoding

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%2012.png)

Fig2: Message & NRZ-M Encoding 

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%2013.png)

Fig4: Message & BIO-L Encoding

![Untitled](LAB%20PROJECT%20REPORT%20G5%20ae27f70b1a1e4a729c8f3aad76623140/Untitled%2014.png)

Fig 6: Message & BIO-S Encoding

*DISCUSSION:*

Implementation of four different encoding techniques: NRZ-L, NRZ-M, NRZ-S, and BIO-M, using an Arduino board and further decoding them.

In the Arduino code, we initialize the serial communication with the computer at a specific baud rate of 9600 bits per second. The serial class in Arduino provides various functions to communicate data through the serial port, such as sending and receiving data.

The microcontroller establishes a serial communication channel with the computer, allowing the user to send and receive data between the computer and the microcontroller. The baud rate of 9600 is a commonly used default rate for serial communication.

1. NRZ-L Encoding: In NRZ-L encoding, the logic level of the signal is set to '0' for a logic '0' and '1' for a logic '1'. To implement NRZ-L encoding using an Arduino board, connect the input data to a digital I/O pin, and set the logic level of the pin to '0' or '1' based on the input data. This can be done using the digitalWrite() function in the Arduino IDE.
2. NRZ-M Encoding: In NRZ-M encoding, the logic level of the signal is set to '1' if the input data is the same as the previous data, and '0' if the input data is different from the previous data. To implement NRZ-M encoding using an Arduino board, store the previous data in a variable and compare it with the current data. Set the logic level of the digital I/O pin to '1' if the data is the same, and '0' if the data is different.
3. NRZ-S Encoding: In NRZ-S encoding, the logic level of the signal is inverted if the input data is a logic '1'. To implement NRZ-S encoding using an Arduino board, connect the input data to a digital I/O pin, and invert the logic level of the pin if the input data is a logic '1'. This can be done using the digitalRead() and digitalWrite() functions in the Arduino IDE.
4. BIO-M Encoding: In BIO-M encoding, a transition is used to represent a logic '1', and no transition is used to represent a logic '0'. To implement BIO-M encoding using an Arduino board, connect the input data to a digital I/O pin, and generate a transition on the pin if the input data is a logic '1'. This can be done using the digitalRead() and digitalWrite() functions in the Arduino IDE.

*CONCLUSION:*

For the safe transfer of data, encoding is the process of transforming the data—or a
the specific sequence of letters, symbols, alphabets, etc.—into a predetermined format. This is important to ensure that the data can be transmitted without any loss, corruption, or unauthorized access. However, there are different types of encoding, and each has its own strengths and weaknesses. For example, some encoding methods are more secure than others, but they may also be slower or require more resources to implement.

Decoding, which involves removing the information from the transformed format, is the opposite of encoding. The decoding process is necessary for the recipient to understand the original message. However, decoding can also be challenging because different encoding methods require different decoding processes. Therefore, it is important to ensure that the encoding and decoding procedures are compatible and well-documented.

In our experiment, we retrieved the original signal for each encoding method after decoding. This allowed us to compare the effectiveness and efficiency of different encoding methods. We found that some methods were more accurate than others, but they also required more time and resources to decode. On the other hand, some methods were faster and more efficient, but they may also be less secure or reliable.

Therefore, it is crucial to choose the appropriate encoding method based on the specific requirements and constraints of the data transmission system. Encoding refers to the process of converting information from its original form into a digital signal that can be transmitted over a communication channel. This process involves several steps, including data compression, error correction, and encryption. Decoding, on the other hand, is the process of recovering the original information from the received digital signal. This process may involve error detection, decryption, and data decompression. By understanding the encoding and decoding processes, we can ensure the safe and efficient transfer of data in various applications, such as telecommunications, computer networking, and digital media.

*CONTRIBUTIONS:*

- Dhruv (B20EE016)- Encoding and decoding schemes of NRZ, transmitter and receiver connection
- Dhruv Shah (B20EE017)- Encoding and decoding schemes of Biphase
- Divyanshi Singh Bora (B20EE018)- Text to binary conversion, transmitter and receiver connection, and binary to text at receiver.

*CHALLENGES:* 

We first tried implementing the schemes through Verilog and were able to implement encoding and decoding logic. But we were not able to convert the text message to binary form.

We tried conversion of text to binary in MATLAB and use a function generator for binary data but there was a clock synchronization problem.

*REFERENCES*:

- Modern Digital and Analog Communication Systems by B.P.Lathi and Zhi Ding
- Communication System 4th edition by Simon Haykin
- Lab Manual
- https://www.arduino.cc/reference